// Copyright 2020 TiKV Project Authors. Licensed under Apache-2.0.

use pd_client::PdClient;
use txn_types::{Key, TimeStamp};

use crate::storage::kv::WriteData;
use crate::storage::lock_manager::LockManager;
use crate::storage::mvcc::metrics::MVCC_CHECK_TXN_STATUS_COUNTER_VEC;
use crate::storage::mvcc::txn::{make_txn_error, MissingLockAction};
use crate::storage::mvcc::{MvccTxn, ReleasedLock, Result as MvccResult};
use crate::storage::txn::commands::{
    Command, CommandExt, ReleasedLocks, TypedCommand, WriteCommand, WriteContext, WriteResult,
};
use crate::storage::txn::Result;
use crate::storage::{ProcessResult, Snapshot, TxnStatus};
use std::mem;

command! {
    /// Check the status of a transaction. This is usually invoked by a transaction that meets
    /// another transaction's lock. If the primary lock is expired, it will rollback the primary
    /// lock. If the primary lock exists but is not expired, it may update the transaction's
    /// `min_commit_ts`. Returns a [`TxnStatus`](TxnStatus) to represent the status.
    ///
    /// This is invoked on a transaction's primary lock. The lock may be generated by either
    /// [`AcquirePessimisticLock`](Command::AcquirePessimisticLock) or
    /// [`Prewrite`](Command::Prewrite).
    CheckTxnStatus:
        cmd_ty => TxnStatus,
        display => "kv::command::check_txn_status {} @ {} curr({}, {}) | {:?}", (primary_key, lock_ts, caller_start_ts, current_ts, ctx),
        content => {
            /// The primary key of the transaction.
            primary_key: Key,
            /// The lock's ts, namely the transaction's start_ts.
            lock_ts: TimeStamp,
            /// The start_ts of the transaction that invokes this command.
            caller_start_ts: TimeStamp,
            /// The approximate current_ts when the command is invoked.
            current_ts: TimeStamp,
            /// Specifies the behavior when neither commit/rollback record nor lock is found. If true,
            /// rollbacks that transaction; otherwise returns an error.
            rollback_if_not_exist: bool,
        }
}

impl CommandExt for CheckTxnStatus {
    ctx!();
    tag!(check_txn_status);
    ts!(lock_ts);
    write_bytes!(primary_key);
    gen_lock!(primary_key);
}

impl CheckTxnStatus {
    /// Check the status of a transaction.
    ///
    /// This operation checks whether a transaction has expired its primary lock's TTL, rollback the
    /// transaction if expired, or update the transaction's min_commit_ts according to the metadata
    /// in the primary lock.
    ///
    /// When transaction T1 meets T2's lock, it may invoke this on T2's primary key. In this
    /// situation, `self.start_ts` is T2's `start_ts`, `caller_start_ts` is T1's `start_ts`, and
    /// the `current_ts` is literally the timestamp when this function is invoked. It may not be
    /// accurate.
    ///
    /// Returns (`lock_ttl`, `commit_ts`, `is_pessimistic_txn`).
    /// After checking, if the lock is still alive, it retrieves the Lock's TTL; if the transaction
    /// is committed, get the commit_ts; otherwise, if the transaction is rolled back or there's
    /// no information about the transaction, results will be both 0.
    pub fn check_txn_status<S: Snapshot, P: PdClient + 'static>(
        self,
        txn: &mut MvccTxn<S, P>,
    ) -> MvccResult<(TxnStatus, Option<ReleasedLock>)> {
        fail_point!("check_txn_status", |err| Err(make_txn_error(
            err,
            &self.primary_key,
            txn.start_ts,
        )
        .into()));

        match txn.reader.load_lock(&self.primary_key)? {
            Some(mut lock) if lock.ts == txn.start_ts => {
                let is_pessimistic_txn = !lock.for_update_ts.is_zero();

                if lock.ts.physical() + lock.ttl < self.current_ts.physical() {
                    // If the lock is expired, clean it up.
                    let released = txn.check_write_and_rollback_lock(
                        self.primary_key,
                        &lock,
                        is_pessimistic_txn,
                    )?;
                    MVCC_CHECK_TXN_STATUS_COUNTER_VEC.rollback.inc();
                    return Ok((TxnStatus::TtlExpire, released));
                }

                // If lock.min_commit_ts is 0, it's not a large transaction and we can't push forward
                // its min_commit_ts otherwise the transaction can't be committed by old version TiDB
                // during rolling update.
                if !lock.min_commit_ts.is_zero()
                    // If the caller_start_ts is max, it's a point get in the autocommit transaction.
                    // We don't push forward lock's min_commit_ts and the point get can ingore the lock
                    // next time because it's not committed.
                    && !self.caller_start_ts.is_max()
                    // Push forward the min_commit_ts so that reading won't be blocked by locks.
                    && self.caller_start_ts >= lock.min_commit_ts
                {
                    lock.min_commit_ts = self.caller_start_ts.next();

                    if lock.min_commit_ts < self.current_ts {
                        lock.min_commit_ts = self.current_ts;
                    }

                    txn.put_lock(self.primary_key, &lock);
                    MVCC_CHECK_TXN_STATUS_COUNTER_VEC.update_ts.inc();
                }

                Ok((
                    TxnStatus::uncommitted(
                        lock.ttl,
                        lock.min_commit_ts,
                        lock.use_async_commit,
                        lock.secondaries,
                    ),
                    None,
                ))
            }
            // The rollback must be protected, see more on
            // [issue #7364](https://github.com/tikv/tikv/issues/7364)
            _ => txn
                .check_txn_status_missing_lock(
                    self.primary_key,
                    MissingLockAction::rollback(self.rollback_if_not_exist),
                )
                .map(|s| (s, None)),
        }
    }
}

impl<S: Snapshot, L: LockManager, P: PdClient + 'static> WriteCommand<S, L, P> for CheckTxnStatus {
    fn process_write(
        mut self,
        snapshot: S,
        context: WriteContext<'_, L, P>,
    ) -> Result<WriteResult> {
        let mut txn = MvccTxn::new(
            snapshot,
            self.lock_ts,
            !self.ctx.get_not_fill_cache(),
            context.pd_client,
        );

        let mut released_locks = ReleasedLocks::new(self.lock_ts, TimeStamp::zero());
        let ctx = mem::take(&mut self.ctx);
        let (txn_status, released) = self.check_txn_status(&mut txn)?;
        released_locks.push(released);
        // The lock is released here only when the `check_txn_status` returns `TtlExpire`.
        if let TxnStatus::TtlExpire = txn_status {
            released_locks.wake_up(context.lock_mgr);
        }

        context.statistics.add(&txn.take_statistics());
        let pr = ProcessResult::TxnStatus { txn_status };
        let write_data = WriteData::from_modifies(txn.into_modifies());
        Ok(WriteResult {
            ctx,
            to_be_write: write_data,
            rows: 1,
            pr,
            lock_info: None,
        })
    }
}
